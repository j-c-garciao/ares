# -*- coding: utf-8 -*-
"""Chekuri_Khanna_Shepherd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xhJDWe8qG3Z70Ij90LizQg7yDr8TMCKx
"""

# multiroute_mip.py
# Requisitos: networkx, pulp
# pip install pulp

import networkx as nx
from itertools import islice
import pulp
import math
import time


def generate_candidate_paths(G, s, t, max_paths=200, weight_attr='capacity'):
    """
    Genera rutas simples candidatas s->t usando shortest_simple_paths con peso
    = 1/capacity (intenta priorizar rutas con aristas de mayor capacidad).
    Devuelve una lista de paths (cada path es lista de nodos).
    Ideas tomadas de Chekuri, C. (2008). Multicommodity Flow, Well-linked Terminals and Routing Problems. In: Kao, MY. (eds) Encyclopedia of Algorithms. Springer, Boston, MA. https://doi.org/10.1007/978-0-387-30162-4_244
    """
    # Construir peso = 1/(capacity + eps) para que caminos con aristas grandes sean 'más cortos'
    eps = 1e-9
    Gw = G.copy()
    for u, v, data in Gw.edges(data=True):
        cap = data.get(weight_attr, 1.0)
        Gw[u][v]['_w'] = 1.0 / (cap + eps)
    try:
        paths_generator = nx.shortest_simple_paths(Gw, s, t, weight='_w')
        paths = list(islice(paths_generator, max_paths))
        return paths
    except Exception as e:
        # si la generación falla (p. ej. no hay caminos), devolvemos lista vacía
        return []

def multiroute_flow_mip(G, s, t, k, max_paths=200, capacity_attr='capacity', verbose=False):
    """
    Aproximación MIP para k-route multiroute flow:
      - G: nx.DiGraph con atributo 'capacity' en aristas
      - s,t: source, sink
      - k: número máximo de rutas a usar
      - max_paths: número máximo de rutas candidatas a generar
    Retorna:
      total_flow, selected_paths (list of (path, flow)), status
    """
    # 1) generar rutas candidatas
    paths = generate_candidate_paths(G, s, t, max_paths=max_paths, weight_attr=capacity_attr)
    if len(paths) == 0:
        return 0.0, [], "NO_PATHS"

    # 2) Precomputar aristas en cada path y M (big-M)
    edge_to_index = {e: i for i, e in enumerate(G.edges())}
    edge_caps = {e: G[e[0]][e[1]].get(capacity_attr, 0.0) for e in G.edges()}
    M = max(edge_caps.values()) if edge_caps else 0.0
    if M <= 0:
        return 0.0, [], "NO_CAPACITY"

    path_edges = []
    for p in paths:
        edges_in_p = []
        for u, v in zip(p, p[1:]):
            edges_in_p.append((u, v))
        path_edges.append(edges_in_p)

    # 3) Construir MIP con PuLP
    prob = pulp.LpProblem("k_route_multiroute_flow_MIP", pulp.LpMaximize)

    # Variables
    f_vars = [pulp.LpVariable(f"f_{i}", lowBound=0, cat='Continuous') for i in range(len(paths))]
    y_vars = [pulp.LpVariable(f"y_{i}", cat='Binary') for i in range(len(paths))]

    # Objetivo: maximizar suma de f_p
    prob += pulp.lpSum(f_vars)

    # Restricción: f_p <= M * y_p
    for i in range(len(paths)):
        prob += f_vars[i] <= M * y_vars[i]

    # Restricción: sum y_p <= k
    prob += pulp.lpSum(y_vars) <= k

    # Restricción por arista: suma de f_p para rutas que usan la arista <= cap_e
    for e in G.edges():
        # sumar f_i para todos i tal que e in path_edges[i]
        involved = []
        for i, edges_in_p in enumerate(path_edges):
            # compare edges (u,v) exactly
            if e in edges_in_p:
                involved.append(f_vars[i])
        if involved:
            prob += pulp.lpSum(involved) <= edge_caps[e]

    # Resolver
    solver = pulp.PULP_CBC_CMD(msg=1 if verbose else 0, timeLimit=None)
    result = prob.solve(solver)

    status = pulp.LpStatus[result]
    if verbose:
        print("Solver status:", status)

    # 4) Extraer solución
    selected = []
    total_flow = 0.0
    for i, p in enumerate(paths):
        fi = pulp.value(f_vars[i])
        yi = pulp.value(y_vars[i])
        if fi is None:
            fi = 0.0
        if fi > 1e-9:
            selected.append((p, float(fi), int(round(yi)) if yi is not None else None))
            total_flow += fi

    return total_flow, selected, status

# -------------------------
# Ejemplo de uso con el grafo que compartiste
if __name__ == "__main__":
    edges = [
        (0,1,2000),(0,2,1600),(1,2,250),(1,3,3000),(1,4,1000),
        (2,7,1000),(2,8,400),(3,4,2000),(3,5,2000),(3,6,3000),
        (4,6,2000),(5,6,2000),(5,10,1500),(6,10,1200),
        (7,8,1000),(7,9,1600),(8,9,500),(9,10,500)
    ]
    G = nx.DiGraph()
    for u,v,c in edges:
        G.add_edge(u,v,capacity=c)


    tt = time.perf_counter()
    s, t = 0, 10
    for k in [5]:
        total_flow, sel, status = multiroute_flow_mip(G, s, t, k, max_paths=300, verbose=True)
        print("\n=== RESULT k =", k, "status:", status, "total_flow:", total_flow)
        for path, f, y in sel:
            print("flow=", f, " used=", y, " path=", path)
    elapsed_time = time.perf_counter() - tt
    print(elapsed_time)