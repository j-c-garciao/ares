# -*- coding: utf-8 -*-
"""Aggarwal_Orlin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k-PSbuDbJKAVworVNOuYetD34caRPDWi
"""

"""
aggarwal_orlin_practical.py

Implementación práctica inspirada en Aggarwal & Orlin:
 - Variante A: single max-flow + decomposition (práctico)
 - Variante B: sequence of min-cuts (up to R) + contract/reduce + single max-flow

NOTA: implementación práctica/ingenieril inspirada en las ideas del artículo
C. C.AggarwalandJ. B.Orlin, On Multiroute Maximum Flows in Networks, Networks, 39(1), 2002, 43-52

Si quieres que implemente literalmente cada paso teórico del paper (p. ej. la prueba
paramétrica exacta o la versión con acotaciones log(U)), puedo hacerlo después de
repasar el texto preciso del artículo (ya lo localizaste).
"""

import networkx as nx
from collections import deque
from copy import deepcopy
import math
import time



# -----------------------
# Helper: decomposición de flujo (extrae rutas s->t de un flow_dict)
def flow_decomposition_from_flowdict(flow_dict, s, t, eps=1e-12):
    residual = {}
    for u, outs in flow_dict.items():
        residual[u] = {}
        for v, f in outs.items():
            if f > eps:
                residual[u][v] = float(f)
    routes = []
    while True:
        parent = {}
        q = deque([s])
        found = False
        while q:
            u = q.popleft()
            if u not in residual:
                continue
            for v, cap in list(residual[u].items()):
                if cap > eps and v not in parent and v != s:
                    parent[v] = u
                    if v == t:
                        found = True
                        q.clear()
                        break
                    q.append(v)
        if not found:
            break
        # reconstruct path
        path = []
        cur = t
        bottleneck = float('inf')
        while cur != s:
            prev = parent[cur]
            path.append(cur)
            bottleneck = min(bottleneck, residual[prev][cur])
            cur = prev
        path.append(s)
        path.reverse()
        # register and subtract
        routes.append((path, bottleneck))
        for u, v in zip(path, path[1:]):
            residual[u][v] -= bottleneck
            if residual[u][v] <= eps:
                del residual[u][v]
                if len(residual[u]) == 0:
                    del residual[u]
    return routes

# -----------------------
# Variante A: una llamada a max-flow + descomposición (práctica)
def aggarwal_orlin_variantA(G, s, t, k=None, flow_func=None):
    """
    Variante A: llamada única a max-flow + descomposición.
    Retorna: total_flow_k, selected_routes, full_flow_value, full_routes
    """
    if flow_func is None:
        flow_func = nx.algorithms.flow.preflow_push
    full_flow_value, flow_dict = nx.maximum_flow(G, s, t, flow_func=flow_func)
    full_routes = flow_decomposition_from_flowdict(flow_dict, s, t)
    full_routes.sort(key=lambda x: x[1], reverse=True)
    if k is None:
        selected_routes = full_routes.copy()
    else:
        selected_routes = full_routes[:k]
    total_flow_k = sum(f for _, f in selected_routes)
    return total_flow_k, selected_routes, full_flow_value, full_routes

# -----------------------
# Utils para contraer / reducir grafo tras un min-cut
def contract_side(G, side_nodes, new_node_label):
    """
    Contrae el conjunto side_nodes en un único nodo new_node_label.
    Devuelve un nuevo DiGraph (copia) con la contracción hecha.
    Nota: conservamos capacidades sumando paralelas.
    """
    Gc = nx.DiGraph()
    # map old node to new node
    mapping = {}
    for u in G.nodes():
        if u in side_nodes:
            mapping[u] = new_node_label
        else:
            mapping[u] = u
    # añadir aristas con capacidades combinadas si colisionan
    for u, v, data in G.edges(data=True):
        cu = mapping[u]
        cv = mapping[v]
        cap = data.get('capacity', 1.0)
        if cu == cv:
            continue
        # sumar si ya existe
        if Gc.has_edge(cu, cv):
            Gc[cu][cv]['capacity'] += cap
        else:
            Gc.add_edge(cu, cv, capacity=float(cap))
    return Gc

# -----------------------
# Variante B: sequence of min-cuts up to R iterations, contract, then one max-flow
def aggarwal_orlin_variantB(G, s, t, k=None, max_iters=None, flow_func=None, prefer_logU=True):
    """
    Variante inspirada en Aggarwal & Orlin: secuencia de min-cuts (R iteraciones)
    seguida de una sola llamada a max-flow en el grafo reducido/contraído.
    Parámetros:
      - G : nx.DiGraph con atributo 'capacity'
      - s, t : source, sink
      - k : numero de rutas deseado (opcional, usado para recortar resultados)
      - max_iters : número máximo de min-cuts a realizar. Si None, se elige un R razonable:
            R = min(k, ceil(log2(U)) + 1) si prefer_logU y k dado; si no, min(k,10).
            (esto aproxima la idea de Aggarwal de usar O(min{log(KU), K}) cortes)
      - prefer_logU : si True, intenta estimar U = max capacity y usa log2(U)
    Retorna:
      total_flow_k, selected_routes, reduced_flow_value, full_routes_reconstructed
    """
    if flow_func is None:
        flow_func = nx.algorithms.flow.preflow_push

    # estimar U
    U = 0
    for _,_,d in G.edges(data=True):
        U = max(U, float(d.get('capacity', 0.0)))
    # determinar R
    if max_iters is None:
        if prefer_logU and U > 0 and k is not None:
            R = min(k, int(math.ceil(math.log2(U + 1))) + 1)
        elif k is not None:
            R = min(k, 10)
        else:
            # si no hay k, hacemos unas pocas iteraciones (por ejemplo 5)
            R = 5
    else:
        R = max_iters

    # Haremos iterativamente min-cuts y contraemos el lado S (containing s) en un supernodo.
    # Guardamos las particiones (S_i, T_i).
    G_work = G.copy()
    contracted_label_prefix = "__C"
    contract_count = 0
    contraction_history = []  # lista de (S_nodes, label)
    for it in range(R):
        try:
            cut_value, (S, T) = nx.minimum_cut(G_work, s, t, capacity='capacity')
        except Exception as e:
            # si mincut falla (ej. no hay camino), rompemos
            break
        # si el cut_value es infinito o 0 y S contains s and t separated, podemos parar
        if cut_value == 0:
            # no capacidad entre s y t
            break
        # registrar S
        label = contracted_label_prefix + str(contract_count)
        contraction_history.append((set(S), label))
        contract_count += 1
        # contraer S en label
        G_work = contract_side(G_work, S, label)
        # actualizar s label if s was contracted
        if s in S:
            s = label
        # actualizar t label if t was contracted (it's unlikely t in S)
        if t in S:
            t = label
        # si s == t, break
        if s == t:
            break

    # Tras las R iteraciones obtenemos G_work (más pequeño)
    # Ejecutamos una única llamada a max-flow en G_work
    try:
        reduced_flow_value, reduced_flow_dict = nx.maximum_flow(G_work, s, t, flow_func=flow_func)
    except Exception as e:
        # si algo falla, retornamos vacío
        return 0.0, [], 0.0, []

    # descomponer flujo en G_work
    reduced_routes = flow_decomposition_from_flowdict(reduced_flow_dict, s, t)

    # Ahora *reconstruimos* (aproximadamente) rutas en el grafo original G:
    # cada ruta en G_work es una secuencia de nodos que pueden incluir supernodos
    # (labels). Reemplazamos cada supernodo por una representative path inside that contracted S.
    # Para la reconstrucción simple: expandimos cada supernodo por una ruta interna s->t hallada
    # por BFS en el subgrafo original restringido a los nodos de S.
    # Esta reconstrucción es heurística/constructiva.
    def expand_route(route_nodes, contraction_history, G_original):
        """
        Dada una lista de nodes que puede contener contracted labels,
        los expandimos por rutas internas simples:
          - si encontramos label L in contraction_history with node set S,
            buscamos en G_original un camino que atraviese S desde entering node to exiting node.
        """
        expanded = []
        for i in range(len(route_nodes)-1):
            u = route_nodes[i]
            v = route_nodes[i+1]
            # Si u no es contracted and v not contracted => edge exists in original
            if not str(u).startswith(contracted_label_prefix) and not str(v).startswith(contracted_label_prefix):
                expanded.append(u)
            elif str(u).startswith(contracted_label_prefix) and not str(v).startswith(contracted_label_prefix):
                # need a path from some node in original S_u that connects to v
                # pick a node x in S_u that has edge to v in original G
                S_set = None
                label = u
                for Sset, lab in contraction_history:
                    if lab == label:
                        S_set = Sset
                        break
                chosen = None
                if S_set is not None:
                    # search for a node x in S_set with edge x->v in G_original
                    for x in S_set:
                        if G_original.has_edge(x, v):
                            chosen = x
                            break
                if chosen is None:
                    # fallback: pick any node in S_set
                    chosen = next(iter(S_set)) if S_set else label
                expanded.append(chosen)
            elif not str(u).startswith(contracted_label_prefix) and str(v).startswith(contracted_label_prefix):
                # entering a contracted supernode: choose representative node in S_v that has edge from u
                S_set = None
                label = v
                for Sset, lab in contraction_history:
                    if lab == label:
                        S_set = Sset
                        break
                chosen = None
                if S_set is not None:
                    for y in S_set:
                        if G_original.has_edge(u, y):
                            chosen = y
                            break
                if chosen is None:
                    chosen = next(iter(S_set)) if S_set else label
                expanded.append(u)
            else:
                # both are contracted labels (rare); choose any rep
                expanded.append(u)
        # add last node
        expanded.append(route_nodes[-1])
        # remove duplicates while keeping order
        final = []
        for node in expanded:
            if not final or final[-1] != node:
                final.append(node)
        return final

    # Reconstruir todas las rutas
    full_routes_reconstructed = []
    for route_nodes, flow_amt in reduced_routes:
        expanded = expand_route(route_nodes, contraction_history, G)
        full_routes_reconstructed.append((expanded, flow_amt))

    # ordenar y seleccionar top-k si apply
    full_routes_reconstructed.sort(key=lambda x: x[1], reverse=True)
    if k is None:
        sel_routes = full_routes_reconstructed.copy()
    else:
        sel_routes = full_routes_reconstructed[:k]
    total_flow_k = sum(f for _, f in sel_routes)

    return total_flow_k, sel_routes, reduced_flow_value, full_routes_reconstructed

# -----------------------
# Ejemplo de uso combinado
if __name__ == "__main__":
    # Grafo de prueba (el que proporcionaste anteriormente)
    edges = [
        (0,1,2000),(0,2,1600),(1,2,250),(1,3,3000),(1,4,1000),
        (2,7,1000),(2,8,400),(3,4,2000),(3,5,2000),(3,6,3000),
        (4,6,2000),(5,6,2000),(5,10,1500),(6,10,1200),
        (7,8,1000),(7,9,1600),(8,9,500),(9,10,500)
    ]
    
    tt = time.perf_counter()
    G = nx.DiGraph()
    for u,v,c in edges:
        G.add_edge(u,v,capacity=c)

    s, t = 0, 10

    print("=== Variante A (single max-flow + decomposition) ===")
    totalA, selA, fullA, allA = aggarwal_orlin_variantA(G, s, t, k=5)
    print("max-flow (A) =", fullA)
    print("routes (A):")
    for p,f in selA:
        print(" ", p, f)

    
    print("\n=== Variante B (min-cut seq + contract + single max-flow) ===")
    totalB, selB, reducedB, fullB = aggarwal_orlin_variantB(G, s, t, k=5)
    print("reduced max-flow (B) =", reducedB)
    print("reconstructed routes (B):")
    for p,f in selB:
        print(" ", p, f)
    
    elapsed_time = time.perf_counter() - tt
    print(elapsed_time)
