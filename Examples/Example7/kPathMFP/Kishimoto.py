# -*- coding: utf-8 -*-
"""Kishimoto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NvBANxyZij7uvnF0kaFR1oo4Id0VzoWF
"""

import networkx as nx
import time

def kishimoto_k_route_flow(G, s, t, k=None):
    """
    Versión práctica del algoritmo de Kishimoto para el máximo flujo multiruta.
    Parámetros:
        G : nx.DiGraph con atributo 'capacity' en las aristas.
        s : nodo fuente
        t : nodo sumidero
        k : número de rutas máximo (None = sin restricción)
    Retorna:
        total_flow : flujo máximo alcanzable con <= k rutas
        routes : lista de (ruta, flujo asignado)

    Ideas tomadas de W. Kishimoto, A Method for Obtaining the Maximum Multiroute Flows in a Network, Networks, 27(4), July 1996, 279-291.

    """
    # 1) Calcular flujo máximo con Edmonds–Karp
    flow_value, flow_dict = nx.maximum_flow(G, s, t, flow_func=nx.algorithms.flow.edmonds_karp)

    # 2) Descomponer el flujo en rutas simples
    routes = []
    residual = {u: dict(v) for u, v in flow_dict.items()}  # copia del flujo
    while True:
        # Buscar un camino s->t con flujo positivo
        stack = [(s, [s], float('inf'))]
        visited = set()
        found_path = None
        while stack:
            node, path, bottleneck = stack.pop()
            if node == t:
                found_path = (path, bottleneck)
                break
            for neigh, f in residual[node].items():
                if f > 0 and neigh not in path:
                    stack.append((neigh, path + [neigh], min(bottleneck, f)))
        if not found_path:
            break
        path, fpath = found_path
        routes.append((path, fpath))
        # Actualizar flujo residual
        for u, v in zip(path, path[1:]):
            residual[u][v] -= fpath

    # 3) Ordenar rutas por flujo y seleccionar las top-k si aplica
    routes.sort(key=lambda x: x[1], reverse=True)
    if k is not None:
        routes = routes[:k]

    total_flow = sum(f for _, f in routes)
    return total_flow, routes


# ==============================
# Ejemplo de uso
if __name__ == "__main__":
    G = nx.DiGraph()
    edges = [
        (1,2,2000),(1,3,1600),
        (2,3,250),(2,4,3000),
        (2,5,1000),(3,8,1000),
        (3,9,400),(4,5,2000),
        (4,6,2000),(4,7,3000),
        (5,7,2000),(6,7,2000),
        (6,11,1500),(7,11,1200),
        (8,9,1000),(8,10,1600),
        (9,10,500),(10,11,500)
    ]

for u,v,c in edges:
  G.add_edge(u,v,capacity=c)

t = time.perf_counter()
for k in [1,2,3,None]:
  flow, routes = kishimoto_k_route_flow(G,1,11,k)
  print(f"k={k} → flujo={flow}")
  for path, f in routes:
    print(f"   ruta {path} con {f}")

flow, routes = kishimoto_k_route_flow(G,1,11,k)
print(f"k={k} → flujo={flow}")
for path, f in routes:
  print(f"   ruta {path} con {f}")

elapsed_time = time.perf_counter() - t
print(elapsed_time)